using Microsoft.CognitiveServices.Speech;
using Microsoft.Extensions.AI;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using TimShaw.VoiceBox.Components;
using TimShaw.VoiceBox.Core;
using TimShaw.VoiceBox.Generics;
using UnityEditor;
using UnityEngine;
using static TimShaw.VoiceBox.Core.ChatUtils;

namespace TimShaw.VoiceBox.Core
{
    /// <summary>
    /// Manages AI services, acting as a central hub for chat, speech-to-text (STT), and text-to-speech (TTS) functionalities.
    /// <br></br>
    /// <br></br>
    /// This class follows the Singleton pattern to ensure a single instance manages all AI interactions.
    /// <br></br>
    /// If you want to use multiple chat services or TTS services, see the <see cref="ChatManager"/> and <see cref="TTSManager"/> classes
    /// </summary>
    public class AIManager : MonoBehaviour
    {
        /// <summary>
        /// Gets the singleton instance of the AIManager.
        /// </summary>
        public static AIManager Instance { get; private set; }

        private readonly CancellationTokenSource internalCancellationTokenSource = new CancellationTokenSource();

        /// <summary>
        /// Path to an api keys json file.
        /// </summary>
        [Tooltip("Path to an api keys json file.")]
        [SerializeField] public string apiKeysJsonPath = "";

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
        [Header("Service Configurations")]
        [Tooltip("Configuration asset for the chat service (e.g., GeminiConfig, ChatGPTConfig).")]
        [SerializeField] public GenericChatServiceConfig chatServiceConfig;

        [Tooltip("Configuration asset for the STT service (e.g., AzureConfig).")]
        [SerializeField] public GenericSTTServiceConfig speechToTextConfig;

        [Tooltip("Configuration asset for the TTS service (e.g., ElevenlabsConfig).")]
        [SerializeField] public GenericTTSServiceConfig textToSpeechConfig;
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        private IChatService _chatService;
        /// <summary>
        /// The chat service generated by the <see cref="ServiceFactory"/>.
        /// </summary>
        public IChatService ChatService { get => _chatService; set => _chatService = value; }

        private ISpeechToTextService _sttService;
        /// <summary>
        /// The STT service generated by the <see cref="ServiceFactory"/>.
        /// </summary>
        public ISpeechToTextService SpeechToTextService { get => _sttService; set => _sttService = value; }

        private ITextToSpeechService _ttsService;
        /// <summary>
        /// The TTS service generated by the <see cref="ServiceFactory"/>.
        /// </summary>
        public ITextToSpeechService TextToSpeechService { get => _ttsService; set => _ttsService = value; }

#if UNITY_EDITOR
        [MenuItem("GameObject/VoiceBox/AI Manager", false, 10)]
#endif
        static void CreateAIManagerObj()
        {
            if (FindFirstObjectByType<AIManager>())
            {
                Debug.LogError("Error creating AI Manager: only 1 AI manager can exist in a scene at a time.");
                return;
            }
            var manager = new GameObject("_AIManager");
            manager.AddComponent<AIManager>();
        }

        /// <summary>
        /// Loads API keys from direct arguments, environment variables, or a JSON file (in that order of precedence)
        /// </summary>
        /// <param name="keysFile">Optional path to the JSON file with API keys.</param>
        /// <param name="chatKey">Optional, direct API key for the chat service.</param>
        /// <param name="sttKey">Optional, direct API key for the Speech-to-Text service.</param>
        /// <param name="ttsKey">Optional, direct API key for the Text-to-Speech service.</param>
        public void LoadAPIKeys(string keysFile = null, string chatKey = null, string sttKey = null, string ttsKey = null)
        {
            // Load from JSON file if provided
            Dictionary<string, string> apiKeysFromFile = null;
            if (!string.IsNullOrEmpty(keysFile))
            {
                apiKeysFromFile = LoadKeysFromFile(keysFile);
            }

            // Set API keys with precedence: direct > environment > JSON file
            if (chatServiceConfig != null)
            {
                chatServiceConfig.apiKey = GetApiKey(chatKey, chatServiceConfig.apiKeyJSONString, chatServiceConfig.apiKeyJSONString, apiKeysFromFile);
                if (string.IsNullOrEmpty(chatServiceConfig.apiKey))
                    Debug.LogWarning("Chat service API key not found.");
            }

            if (speechToTextConfig != null)
            {
                speechToTextConfig.apiKey = GetApiKey(sttKey, speechToTextConfig.apiKeyJSONString, speechToTextConfig.apiKeyJSONString, apiKeysFromFile);
                if (string.IsNullOrEmpty(speechToTextConfig.apiKey))
                    Debug.LogWarning("STT service API key not found.");
            }

            if (textToSpeechConfig != null)
            {
                textToSpeechConfig.apiKey = GetApiKey(ttsKey, textToSpeechConfig.apiKeyJSONString, textToSpeechConfig.apiKeyJSONString, apiKeysFromFile);
                if (string.IsNullOrEmpty(textToSpeechConfig.apiKey))
                    Debug.LogWarning("TTS service API key not found.");
            }
        }

        /// <summary>
        /// Retrieves the API key based on the established precedence.
        /// </summary>
        private string GetApiKey(string directKey, string envVar, string jsonKey, Dictionary<string, string> keysFromFile)
        {
            // 1. Direct parameter
            if (!string.IsNullOrEmpty(directKey))
            {
                return directKey;
            }

            // 2. Environment variable
            if (!string.IsNullOrEmpty(envVar))
            {
                string envValue = Environment.GetEnvironmentVariable(envVar, EnvironmentVariableTarget.User);
                if (!string.IsNullOrEmpty(envValue))
                {
                    return envValue;
                }
            }

            // 3. JSON file
            if (keysFromFile != null && !string.IsNullOrEmpty(jsonKey) && keysFromFile.ContainsKey(jsonKey))
            {
                return keysFromFile[jsonKey];
            }

            return null;
        }

        /// <summary>
        /// Loads API keys from a JSON file.
        /// </summary>
        private Dictionary<string, string> LoadKeysFromFile(string keysFile)
        {
            try
            {
                string jsonContent = File.ReadAllText(keysFile);
                return JsonSerializer.Deserialize<Dictionary<string, string>>(jsonContent);
            }
            catch (FileNotFoundException)
            {
                Debug.LogWarning($"[AI Manager] API keys json file not found at: {keysFile}");
                return null;
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AI Manager] Error reading API keys file: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Unloads the API keys from the service configurations.
        /// </summary>
        private void UnloadAPIKeys()
        {
            if (chatServiceConfig)
                chatServiceConfig.apiKey = "";

            if (speechToTextConfig)
                speechToTextConfig.apiKey = "";

            if (textToSpeechConfig)
                textToSpeechConfig.apiKey = "";
        }

        /// <summary>
        /// Initializes the singleton instance, loads API keys, and sets up the AI services.
        /// </summary>
        private void Awake()
        {
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }
            Instance = this;
            DontDestroyOnLoad(gameObject);

            LoadAPIKeys(apiKeysJsonPath.Length > 0 ? apiKeysJsonPath : null);

            ChatService = ServiceFactory.CreateChatService(chatServiceConfig);
            SpeechToTextService = ServiceFactory.CreateSttService(speechToTextConfig);
            TextToSpeechService = ServiceFactory.CreateTtsService(textToSpeechConfig);
        }

        /// <summary>
        /// Cancels all running tasks and unloads API keys when the application quits.
        /// </summary>
        private void OnDestroy()
        {
            internalCancellationTokenSource.Cancel();
            UnloadAPIKeys();
        }

        /// <summary>
        /// Sends a conversation history to the configured chat service.
        /// </summary>
        /// <param name="messageHistory">A list of chat messages representing the conversation history.</param>
        /// <param name="options">Request-level settings.</param>
        /// <param name="onSuccess">Callback invoked when the message is successfully sent, returning the response.</param>
        /// <param name="onError">Callback invoked when an error occurs.</param>
        /// <param name="token"></param>
        public void SendChatMessage(
            List<ChatUtils.VoiceBoxChatMessage> messageHistory,
            ChatUtils.VoiceBoxChatCompletionOptions options,
            Action<ChatUtils.VoiceBoxChatMessage> onSuccess,
            Action<string> onError,
            CancellationToken token = default)
        {
            if (ChatService == null)
            {
                onError?.Invoke("Chat service is not initialized. Check AIManager configuration.");
                return;
            }

            token = CancellationTokenSource.CreateLinkedTokenSource(token, internalCancellationTokenSource.Token).Token;

            Task.Run(() => ChatService.SendMessage(messageHistory, options, onSuccess, onError, token));
        }

        /// <summary>
        /// Sends a message to the Chat service and streams the response.
        /// </summary>
        /// <param name="messageHistory">The history of messages in the conversation.</param>
        /// <param name="options">Request-level settings.</param>
        /// <param name="onChunkReceived">Callback invoked when a chunk of the response is received.</param>
        /// <param name="onComplete">Callback invoked when the response is complete.</param>
        /// <param name="onError">Callback invoked when an error occurs.</param>
        /// <param name="token"></param>
        public async void StreamChatMessage(
            List<ChatUtils.VoiceBoxChatMessage> messageHistory,
            ChatUtils.VoiceBoxChatCompletionOptions options,
            Action<ChatResponseUpdate> onChunkReceived,
            Action onComplete,
            Action<string> onError,
            CancellationToken token = default
        )
        {
            if (ChatService == null)
            {
                onError?.Invoke("Chat service is not initialized. Check AIManager configuration.");
                return;
            }

            token = CancellationTokenSource.CreateLinkedTokenSource(token, internalCancellationTokenSource.Token).Token;

            try
            {
                await Task.Run(() => ChatService.SendMessageStream(messageHistory, options, onChunkReceived, onComplete, onError, token));
            }
            catch (Exception ex)
            {
                Debug.LogException(ex);
            }
        }

        /// <summary>
        /// Starts transcribing audio from the microphone using the configured STT service.
        /// </summary>
        public void StartSpeechTranscription(CancellationToken token = default)
        {
            if (SpeechToTextService == null)
            {
                Debug.Log("STT Service not initialized. Check AIManager configuration.");
                return;
            }
            token = CancellationTokenSource.CreateLinkedTokenSource(token, internalCancellationTokenSource.Token).Token;
            Debug.Log("VoiceBox: Starting speech recognition.");
            Task.Run(() => SpeechToTextService.TranscribeAudioFromMic(token));
        }

        /// <summary>
        /// Stops the ongoing speech transcription.
        /// </summary>
        public void StopSpeechTranscription()
        {
            internalCancellationTokenSource.Cancel();
        }

        /// <summary>
        /// Generates a speech audio file from the given text prompt.
        /// </summary>
        /// <param name="prompt">The text to be converted to speech.</param>
        /// <param name="fileName">The name of the output audio file.</param>
        /// <param name="dir">The directory to save the audio file in.</param>
        /// <param name="token"></param>
        public void GenerateSpeechFileFromText(string prompt, string fileName, string dir, CancellationToken token)
        {
            Task.Run(() => TextToSpeechService.RequestAudioFile(prompt, fileName, dir, token));
        }

        /// <summary>
        /// Generates an AudioClip from the given text prompt.
        /// </summary>
        /// <param name="prompt">The text to be converted to speech.</param>
        /// <param name="onSuccess">Callback invoked with the generated AudioClip on success.</param>
        /// <param name="onError">Callback invoked with an error message on failure.</param>
        public async void GenerateSpeechAudioClipFromText(
            string prompt,
            Action<AudioClip> onSuccess,
            Action<string> onError)
        {
            try
            {
                AudioClip audioClip = await TextToSpeechService.RequestAudioClip(prompt);
                onSuccess?.Invoke(audioClip);
            }
            catch (Exception e)
            {
                onError?.Invoke($"Failed to generate speech: {e.Message}");
            }
        }

        /// <summary>
        /// Requests and streams audio from a text prompt to an AudioSource.
        /// </summary>
        /// <param name="prompt">The text to be converted to speech.</param>
        /// <param name="audioStreamer">The AudioSource to stream the audio to.</param>
        /// <param name="token"></param>
        public void RequestAudioAndStream(string prompt, AudioStreamer audioStreamer, CancellationToken token = default)
        {
            if (audioStreamer)
                audioStreamer.StartStreaming(prompt, TextToSpeechService, token);
            else
                Debug.LogError("Audio Streamer is null.");
        }

        /// <summary>
        /// TODO
        /// </summary>
        /// <param name="audioSource"></param>
        public void StartVoiceAgentPipeline(AudioSource audioSource)
        {
            throw new NotImplementedException();

            // Sample of what I want it to work like:
            /*
            StartSpeechTranscription();
            List<ChatMessage> messages = new();
            SpeechToTextService.OnRecognized += (object s, SpeechRecognitionEventArgs e) =>
            {
                messages.Add(new ChatMessage(ChatRole.User, e.Result.Text));
                StreamChatMessage(
                    messages,
                    null,
                    (chunk) => RequestAudioAndStream(chunk, audioSource),
                    null,
                    (error) => Debug.LogError(error)

                );
            };
            */
        }
    }
}